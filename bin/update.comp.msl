#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"
#pragma clang diagnostic ignored "-Wunused-variable"

#include <metal_stdlib>
#include <simd/simd.h>
#include <metal_atomic>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

// The required alignment of a linear texture of R32Uint format.
constant uint spvLinearTextureAlignmentOverride [[function_constant(65535)]];
constant uint spvLinearTextureAlignment = is_function_constant_defined(spvLinearTextureAlignmentOverride) ? spvLinearTextureAlignmentOverride : 4;
// Returns buffer coords corresponding to 2D texture coords for emulating 2D texture atomics
#define spvImage2DAtomicCoord(tc, tex) (((((tex).get_width() +  spvLinearTextureAlignment / 4 - 1) & ~( spvLinearTextureAlignment / 4 - 1)) * (tc).y) + (tc).x)

struct uniformTime
{
    int time;
};

struct uniformOffset
{
    uint offset;
};

constant uint3 gl_WorkGroupSize [[maybe_unused]] = uint3(16u, 16u, 1u);

constant spvUnsafeArray<int2, 4> _290 = spvUnsafeArray<int2, 4>({ int2(0), int2(0, 1), int2(1), int2(1, 0) });

static inline __attribute__((always_inline))
bool contains(thread const int2& position)
{
    bool _132 = position.x >= 0;
    bool _138;
    if (_132)
    {
        _138 = position.y >= 0;
    }
    else
    {
        _138 = _132;
    }
    bool _145;
    if (_138)
    {
        _145 = position.x < 960;
    }
    else
    {
        _145 = _138;
    }
    bool _152;
    if (_145)
    {
        _152 = position.y < 720;
    }
    else
    {
        _152 = _145;
    }
    return _152;
}

static inline __attribute__((always_inline))
uint hash(thread uint& x)
{
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

static inline __attribute__((always_inline))
uint hash(thread const uint3& v)
{
    uint param = v.y;
    uint _87 = hash(param);
    uint param_1 = v.z;
    uint _93 = hash(param_1);
    uint param_2 = (v.x ^ _87) ^ _93;
    uint _96 = hash(param_2);
    return _96;
}

static inline __attribute__((always_inline))
float floatConstruct(thread uint& m)
{
    m &= 8388607u;
    m |= 1065353216u;
    float f = as_type<float>(m);
    return f - 1.0;
}

static inline __attribute__((always_inline))
float random(thread const float3& v)
{
    uint3 param = as_type<uint3>(v);
    uint param_1 = hash(param);
    float _119 = floatConstruct(param_1);
    return _119;
}

static inline __attribute__((always_inline))
float random(thread const int3& v)
{
    float3 param = float3(v);
    return random(param);
}

static inline __attribute__((always_inline))
bool empty(thread const int2& position, texture2d<uint> readImage)
{
    int2 param = position;
    bool _157 = contains(param);
    bool _169;
    if (_157)
    {
        _169 = readImage.read(uint2(position)).x == 0u;
    }
    else
    {
        _169 = _157;
    }
    return _169;
}

static inline __attribute__((always_inline))
void simulate(thread const int2& position, thread const uint& particles, thread const uint& bitshift, texture2d<uint> readImage, constant uniformTime& _184, texture2d<uint> writeImage, device atomic_uint* writeImage_atomic)
{
    uint particle = (particles >> bitshift) & 255u;
    switch (particle)
    {
        case 2u:
        {
            int3 param = int3(position, _184.time);
            int neighborDirection;
            if (random(param) > 0.5)
            {
                neighborDirection = -1;
            }
            else
            {
                neighborDirection = 1;
            }
            spvUnsafeArray<int2, 3> _216 = spvUnsafeArray<int2, 3>({ position + int2(0, 1), position + int2(-neighborDirection, 1), position + int2(neighborDirection, 1) });
            spvUnsafeArray<int2, 3> neighbors = _216;
            uint bitshift_1;
            for (int i = 0; i < 3; i++)
            {
                int2 param_1 = neighbors[i];
                if (!empty(param_1, readImage))
                {
                    continue;
                }
                if (neighbors[i].x < 0)
                {
                    bitshift_1 = 16u;
                }
                else
                {
                    if (neighbors[i].x > 0)
                    {
                        bitshift_1 = 24u;
                    }
                    else
                    {
                        bitshift_1 = 8u;
                    }
                }
                particle = 2u << bitshift_1;
                uint _262 = atomic_fetch_or_explicit((device atomic_uint*)&writeImage_atomic[spvImage2DAtomicCoord(neighbors[i], writeImage)], particle, memory_order_relaxed);
                return;
            }
            particle = 2u << bitshift;
            uint _271 = atomic_fetch_or_explicit((device atomic_uint*)&writeImage_atomic[spvImage2DAtomicCoord(position, writeImage)], particle, memory_order_relaxed);
            break;
        }
    }
}

kernel void main0(constant uniformOffset& _293 [[buffer(0)]], constant uniformTime& _184 [[buffer(1)]], texture2d<uint> readImage [[texture(0)]], texture2d<uint> writeImage [[texture(1)]], device atomic_uint* writeImage_atomic [[buffer(32767)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    int2 position = (int2(int3(gl_GlobalInvocationID).xy) * int2(2)) + _290[_293.offset % 4u];
    int2 param = position;
    if (!contains(param))
    {
        return;
    }
    uint particles = readImage.read(uint2(position)).x;
    int2 param_1 = position;
    uint param_2 = particles;
    uint param_3 = 0u;
    simulate(param_1, param_2, param_3, readImage, _184, writeImage, writeImage_atomic);
    int2 param_4 = position;
    uint param_5 = particles;
    uint param_6 = 8u;
    simulate(param_4, param_5, param_6, readImage, _184, writeImage, writeImage_atomic);
    int2 param_7 = position;
    uint param_8 = particles;
    uint param_9 = 16u;
    simulate(param_7, param_8, param_9, readImage, _184, writeImage, writeImage_atomic);
    int2 param_10 = position;
    uint param_11 = particles;
    uint param_12 = 24u;
    simulate(param_10, param_11, param_12, readImage, _184, writeImage, writeImage_atomic);
}

